AI-Research (CS 493)
===================

This repository holds our Artificial Intelligence research. This specific project focuses on trying to discover how an agent can use its memories of past actions/results to help it intelligently navigate an unknown environment. Presently, we have tried placing the agent in two different environments which are described below. 

### Passphrase Environment

The passphrase environment places the agent in a situation where it must guess a passphrase of characters that is equivalent to the environment’s password. Extraneous characters may be included in the passphrase the agent guesses. Thus, as long as at some point within a string of characters the agent enters the characters of the in the right order, it will be successful. The environment will inform the agent once it successfully enters an adequate passphrase.

The catch however is that the environment includes a list of equivalencies. An equivalency is a mapping of (at the moment) two characters to a single character.  For example:

    ab -> c
    qr -> d
    hp -> n

The environment will accept the left hand side of the equivalency in place of the right hand side, even though it is not technically a correct character in the passphrase. This means the environment will accept a passphrase from the agent, even if it is not the optimal/correct password. For example, if you had an password `abc`, and an equivalency `a -> df`, then the environment would accept both `abc` and `dfbc` from the agent.

The code important to this environment is contained in `Equiv.java`, `Passphrase.java`, `PassphraseAgent.java`, and `PassphraseEnvironment.java`. 


### State Machine Environment

The State Machine Environment places the agent in a situation where it must guess a string of characters that form a path from the start state to the goal state of a generated State Machine. The number of states in the State Machine is given by a constant in the environment, and the machine’s transition function is generated semi-randomly using a given alphabet. Each state has a constant number of transitions to a different state, provided by a constant in the environment. The characters on which a given state transitions to a new state are chosen randomly, as is the state that is transitioned to when reading that character while in the current state. On all other characters, a given state will transition back to itself. A State Machine is invalid if there is no path from the Start State to the goal. In this case, a new State Machine is generated. 

The string generated by the Agent consists of characters from the given alphabet, and a string is valid as long as it is accepted by the State Machine. The environment will indicate to the Agent when it has reached the Goal state. The Agent will generate a string by randomly entering characters from the alphabet until it has reached the goal. It will then attempt to shorten the string by cutting out any unneeded transitions.

The code important to this environment is contained in the files `Path.java`, `StateMachineAgent.java`, and `StateMachineEnvironment.java`.
